# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hDXbm6xIlpiadZBistbQbLv8yN9cI1ao
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import tensorflow as tf
import tensorflow_probability as tfp
import gpflow
from gpflow.utilities import print_summary, set_trainable, to_default_float
from mpl_toolkits.mplot3d import Axes3D

class mean_f(gpflow.mean_functions.MeanFunction):
  def __init__(self, A1=None, A2=None, b=None):
    MeanFunction.__init__(self)
    A1 = np.ones((1, 1), dtype=default_float()) if A is None else A1
    A2 = np.ones((1, 1), dtype=default_float()) if A is None else A2
    A1, A2 = np.meshgrid(A1, A2)
    A12 = np.dstack([A1, A2]).reshape(len(A1), len(A2), 2)
    b1 = np.zeros(1, dtype=default_float()) if b is None else b
    b2 = np.zeros(1, dtype=default_float()) if b is None else b
    b1, b2 = np.meshgrid(b1, b2)
    b12 =np.dstack([b1,b2]).reshape(len(A1), len(A2), 2)
    self.b = Parameter(b)
  def __call__(self,X):
    return tf.tensordot(X, self.A12, [[-1], [0]]) + self.b12


data = np.array(pd.read_csv('gyro_fake_data_v1.csv'))

Y = Y_plot = data[:100,1].reshape(-1,1)
X1 = X1_plot = data[:100,2]
X2 = X2_plot = data[:100,3]

#np.random.seed(1991)
meanf = gpflow.mean_functions.Zero()
k = gpflow.kernels.Matern12(variance=10.0, lengthscales=[15, 1.0])
X = np.dstack([X1, X2]).reshape(-1, 2)
m = gpflow.models.GPR(data=(X, Y), kernel=k, mean_function=meanf)
opt = gpflow.optimizers.Scipy()
opt_logs = opt.minimize(m.training_loss, m.trainable_variables, options=dict(maxiter=100))

x1_mesh, x2_mesh = np.meshgrid(X1, X2)

resolution = len(Y)
X1_test = np.linspace( 0.4, 1.5, num=resolution )
X2_test = np.linspace( 1.0, 40.0, num=resolution )
X1_test, X2_test = np.meshgrid( X1_test, X2_test )
X_test = np.dstack([X1_test, X2_test]).reshape(resolution, resolution, 2)

print(X_test.shape)

# predict training set
mean, _ = m.predict_y( X_test )
mean = tf.squeeze(mean)

fig = plt.figure()
ax = plt.axes(projection='3d')
ax.plot_surface(X1_test, X2_test, mean, antialiased=True, alpha=0.5, linewidth=0.5, cmap='winter')
ax.scatter3D(X1, X2, Y, marker='o',edgecolors='k', color='r', s=150)
ax.set_xlabel('B-V Index')
ax.set_ylabel('Rotation Period (Days)')
ax.set_zlabel('Age (Gyr)')
plt.show()
plt.legend()

numElems = len(Y)
idx = np.round(np.linspace(0, len(mean1.reshape(numElems**2)) - 1, numElems)).astype(int)
# Picks equal spaced elements from (longer) prediction array so that its shape of data

mu_test = (mean1.reshape(numElems**2)[idx])
sd_test = (np.array(var).reshape(numElems**2)[idx]) 

vals = np.sort([mu_test, sd_test], axis=1)

plt.figure(figsize=(18,9))
plt.errorbar(Y, vals[0,:], yerr=vals[1,:]**2, fmt='bo')
plt.plot(np.linspace( np.min(Y), np.max(Y), num=resolution ), np.linspace( np.min(Y), np.max(Y), num=resolution ), 'r')
plt.show()

Z = (np.sort(data[::10,1])-vals[0,:])/vals[1,:]
print(Y.shape)
import seaborn as sns
plt.hist(Z, density=True, bins=8)
sns.distplot(np.random.normal(size=1000), hist=False)
plt.show()